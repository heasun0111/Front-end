## Front-end
프론트엔드 스터디 공부 내용 정리 </br> </br>


**파스칼 표기법** : 첫 단어를 대문자로 시작하는 표기법 </br>
ex) BackgroundColor, TypeName, PowerPoint

**고차 함수** </br>
고차 함수는 함수를 인자로 받거나 또는 함수를 반환함으로써 작동하는 함수를 말합니다.

**Object**</br>
Object 클래스는 JavaScript의 데이터 유형 중 하나를 나타낸다.
다양한 키 모음 및 더 복잡한 엔티티들을 저장하는 데 사용됩니다.
객체는 Object() 생성자 또는 객체 초기자 / 리터럴 구문을 통해 생성할 수 있습니다.
객체는 사용자(user), 주문(order) 등과 같이 실제 존재하는 개체(entity)를 표현하고자 할 때 생성됩니다.

**this** </br>
user.sayHi()의 내부 코드에서 객체 user에 저장된 이름(name)을 이용해 인사말을 만드는 경우가 이런 경우에 속합니다.

메서드 내부에서 this 키워드를 사용하면 객체에 접근할 수 있습니다.
이때 '점 앞’의 this는 객체를 나타냅니다. 정확히는 메서드를 호출할 때 사용된 객체를 나타내죠

```
let user = {
  name: "John",
  age: 30,

  sayHi() {
    // 'this'는 '현재 객체'를 나타냅니다.
    alert(this.name);
  }

};

user.sayHi(); // John
```
</br>

**Array.prototype.map**</br>
map() 메소드는 입력으로 들어온 배열 내 모든 엘리먼트를 인자로 제공받는 콜백 함수를 호출함으로써 새로운 배열을 만들어냅니다. map() 메소드는 콜백 함수에서 모든 반환된 값을 가져올 것입니다. 그리고 그 값들을 이용한 새로운 배열 하나를 만들어냅니다.
```
const arr1 = [1, 2, 3];
const arr2 = arr1.map(item => item * 2);
console.log(arr2);
```
</br>

**프로토타입(prototype)** </br>
상속되는 속성과 메소드들은 각 객체가 아니라 객체의 생성자의 prototype이라는 속성에 정의되어 있습니다.
모든 객체들이 메소드와 속성들을 상속받기 위한 템플릿으로써 프로토타입 객체(prototype object)를 가진다는 의미입니다
JavaScript에서는 객체 인스턴스와 프로토타입 간에 연결이 구성되며 이 연결을 따라 프로토타입 체인을 타고 올라가며 속성과 메소드를 탐색합니다.

prototype 속성도 하나의 객체이며 프로토타입 체인을 통해 상속하고자 하는 속성과 메소드를 담아두는 버킷으로 주로 사용되는 객체

**함수** </br>
자바스크립트는 함수를 특별한 종류의 값으로 취급합니다.

<함수 표현식>
```
function sayHi() {   // (1) 함수 생성
  alert( "Hello" );
}

let func = sayHi;    // (2) 함수 복사

func(); // Hello     // (3) 복사한 함수를 실행(정상적으로 실행됩니다)!
sayHi(); // Hello    //     본래 함수도 정상적으로 실행됩니다.
```

함수 표현식으로 정의한 함수는 함수가 선언되기 전에 접근하는 게 불가능합니다.

함수 선언문이 코드 블록 내에 위치하면 해당 함수는 블록 내 어디서든 접근할 수 있습니다. 하지만 블록 밖에서는 함수에 접근하지 못합니다.

•	함수는 값입니다. 따라서 함수도 값처럼 할당, 복사, 선언할 수 있습니다.
•	“함수 선언(문)” 방식으로 함수를 생성하면, 함수가 독립된 구문 형태로 존재하게 됩니다.
•	“함수 표현식” 방식으로 함수를 생성하면, 함수가 표현식의 일부로 존재하게 됩니다.
•	함수 선언문은 코드 블록이 실행되기도 전에 처리됩니다. 따라서 블록 내 어디서든 활용 가능합니다.
•	함수 표현식은 실행 흐름이 표현식에 다다랐을 때 만들어집니다.


**콜백 함수** </br>
함수를 함수의 인수로 전달하고, 필요하다면 인수로 전달한 그 함수를 "나중에 호출(called back)"하는 것이 콜백 함수의 개념입니다.

**화살표 함수**
```
let func = (arg1, arg2, ...argN) => expression

let func = function(arg1, arg2, ...argN) {
  return expression;
};
```

**Constructor** </br>
constructor 메서드는 클래스의 인스턴스 객체를 생성하고 초기화하는 특별한 메서드입니다.
인스턴스 객체를 초기화할 때 수행할 초기화 코드를 정의할 수 있습니다.


**화살표 함수** </br>
인자 arg1..argN를 받는 함수 func이 만들어집니다. 함수 func는 화살표(=>) 우측의 표현식(expression)을 평가하고, 평가 결과를 반환합니다.
```
let func = (arg1, arg2, ...argN) => expression
```

**엄격 모드** </br>
하위 호환성 문제로 변경사항 대부분은 ES5의 기본 모드에선 활성화되지 않도록 설계되었습니다. 대신 use strict라는 특별한 지시자를 사용해 엄격 모드(strict mode)를 활성화했을 때만 이 변경사항이 활성화되게 해놓았습니다.
지시자 "use strict", 혹은 'use strict'는 단순한 문자열처럼 생겼습니다. 하지만 이 지시자가 스크립트 최상단에 오면 스크립트 전체가 “모던한” 방식으로 동작합니다.

**변수타입** </br>

**Boolean**
true와 false 둘 중 하나의 값을 갖는 논리적인 요소

**Number**
-(253 -1) ~ 253 -1 사이의 숫자값 하나

**BigInt**
Number의 범위를 넘어서는 큰 정수도 안전하게 저장/ 연산

**String**
String 타입은 텍스트 데이터

**Null**
빈 값을 뜻하는 null타입이다
->타입은 존재하지만, 값은 없다

**Undefined**
값도 없고, 타입도 지정되지 않은 상태

**Symbol**
유일하고 변경 불가능한 기본값

자바스크립트에서는 Undefined를 제외하고는 모두 객체이다.
</br>

**null 이랑 undefined의 차이**</br>
undefined 은 변수를 선언하고 값을 할당하지 않은 상태, null 은 변수를 선언하고 빈 값을 할당한 상태(빈 객체)이다. 즉, undefined는 자료형이 없는 상태이다.

**Null**
빈 값을 뜻하는 null타입이다
->타입은 존재하지만, 값은 없다

**Undefined**
값도 없고, 타입도 지정되지 않은 상태

**클로저**</br>
JS는 함수의 중첩(함수 안에 함수를 정의하는것)을 허용하고, 내부함수가 외부 함수 안에서 정의된 모든 변수와 함수들을 완전하게 접근 할 수 있도록 승인해줍니다.(그리고 외부함수가 접근할수 있는 모든 다른 변수와 함수들까지)
그러나 외부 함수는 내부 함수 안에서 정의된 변수와 함수들에 접근 할 수 없습니다. 이는 내부 함수의 변수에 대한 일종의 캡슐화를 제공합니다. 또한, 내부함수는 외부함수의 범위에 접근할 수 있기 때문에, 내부 함수가 외부 함수의 수명을 초과하여 생존하는 경우, 외부함수에서 선언된 변수나 함수는 외부함수의 실행 기간보다 오래갑니다. 클로저는 내부 함수가 어떻게든 외부 함수 범위 밖의 모든 범위에서 사용 가능해지면 생성됩니다.

**정규 표현식(정규식 연산)**</br>
정규 표현식 리터럴. 다음과 같이 슬래시로 패턴을 감싸서 작성합니다.
const re = /ab+c/
정규 표현식 패턴은 /abc/처럼 단순한 문자로 구성하거나, /ab+c/와 /Chapter (\d+)\.\d*/처럼 단순한 문자와 특수 문자의 조합으로 구성할 수도 있습니다.


