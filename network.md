## 네트워크

#### #1 처리량, 지연시간

네트워크란 노드와 링크가 서로 연결되어 있으며 리소스를 공유하는 집합
노드: 서버, 라우터, 스위치 등 네트워크 장치
링크: 유선, 무선

많은 처리량을 처리, 지연 시간 짧고, 장애 빈도가 적고, 좋은 보안 갖춤 -> 좋은 네트워크

처리량: 링크를 통해 전달되는 단위 시간당 데이터양
처리량은 사용자들이 많이 접속할 때 마다 커지는 트래픽, 네트워크 장치 간의 대역폭, 네트워크 중간에 발생하는 에러 등에 영향
*트래픽(traffic)이란 서버와 스위치 등 네트워크 장치에서 일정 시간 내에 흐르는 데이터의 양을 말한다.

대역폭: 주어진 시간 동안 네트워크 연결을 통해 흐를 수 있는 최대 비트 수

지연 시간: 요청이 처리되는 시간, 어떤 메시지가 두 장치 사이를 왕복하는데 걸린 시간

</br> </br>

#### #2 네트워크 토폴로지와 병목 현상
네트워크 토폴로지는 노드와 링크가 어떻게 배치되어 있는지에 대한 방식 및 연결 형태

-트리 토폴로지
 계층형 토폴로지
 장) 노드의 추가/삭제가 쉽다
 단) 특정 노드에 트래픽이 집중될 때 하위 노드에 영향을 끼칠 수 있다

-버스 토폴로지
 중앙 통신 회선 하나에 여러 개의 노드가 연결되어 공유하는 구성
 근거리 통신망(LAN)에서 사용
 장) 설치 비용이 적고, 신뢰성이 우수하며 중앙 통신 회선에 노드를 추가하거나 삭제하기 쉽다.
 단) 그러나 스푸핑이 가능한 문제!
*스푸핑: LAN상에서 송신부의 패킷을 송신과 관련 없는 다른 호스트에 가지 않도록 하는 스위칭 기능을 마비시키거나 속여서 특정 노드에 해당 패킷이 오도록 처리하는 것

-스타 토폴로지
 중앙에 있는 노드에 모두 연결된 네트워크 구성
 장) 노드를 추가하거나 에러를 탐지하기 쉽고 패킷의 충돌 발생 가능성이 적다
 어떠한 노드에 장애가 발생해도 쉽게 에러를 발견, 장애 노드가 중앙 노드가 아닐 경우 다른 노드에 영향을 끼치는 것이 적다
 단) 중앙 노드에 장애가 발생하면 전체 네트워크를 사용할 수 없고 설치 비용이 고가이다




-링형 토폴로지
 각각의 노드가 양 옆의 두 노드와 연결하여 전체적으로 고리처럼 하나의 연속된 길을 통해 통신을 하는 망 구성 방식
 데이터는 노드에서 노드로 이동을 하게 되며, 각각의 노드는 고리 모양의 길을 통해 패킷을 처리
장) 노드 수가 증가되어도 네트워크상의 손실이 거의 없고 충돌이 발생되는 가능성이 적고, 노드의 고장 발견을 쉽게 찾을 수 있다
단) 네트워크 구성 변경이 어렵고 회선에 장애가 발생하면 전체 네트워크에 영향을 크게 끼친다

-메시 토폴로지
메시(mesh) 토폴로지는 망형 토폴로지라고도 하며 그물망처럼 연결
장) 한 단말 장치에 장애가 발생해도 여러 개의 경로가 존재하므로 네트워크를 계속 사용할 수 있고 트래픽도 분산 처리 가능
단) 노드의 추가가 어렵고 구축 비용과 운용 비용이 고가


토폴로지는 병목 현상을 찾을 때 중요한 기준!!
*병목 현상: 전체 시스템의 성능이나 용량이 하나의 구성 요소로 인해 제한을 받는 현상

</br> </br>

#### #3 LAN, MAN, WAN
네트워크를 규모 기반으로 분류할 시 LAN, MAN, WAN으로 나눌 수 있다.

LAN (Local Area Network)
근거리 통신망 (사무실, 개인적으로 소유 가능한 규모)
전송 속도가 빠르고 혼잡하지 않다.

MAN (Metropolitan Area Network)
대도시 지역 네트워크 (서울시 정도 규모)
전송 속도는 평균이며 LAN보다는 더 많이 혼잡하다.

WAN (Wide Area Network)
광역 네트워크를 의미 (국가, 대륙 같은 넓은 지역)
전송 속도는 낮으며 MAN보다 더 혼잡하다.



#### #3 브라우저 렌더링 과정
1. DOM 트리 구축
 하나의 html 페이지는 div, span 등 각각의 요소를 가집니다. 각 요소는 하나하나 노드로 설정이 되어 트리 형태로 저장되는데, 이를 DOM 트리라고 한다.

2. 렌더트리와 렌더레이어 생성
각각의 노드는 CSS파서에 의해 정해진 스타일 규칙이 적용되어 있다. 
이런 규칙에 따라 CSSOM이라는 트리가 만들어지고 
미리 만들어놓은 DOM트리 내에 있는 노드와 함께 렌더 객체가 생성되며
이들이 모여 병렬적인 렌더트리가 생성된다.

이때 display:none이 포함된 노드는 지워지고 font-size 등 상속적인 스타일은 부모노드에만 위치하도록 설계하는 등의 최적화를 거쳐 렌더레이어가 완성된다.

3. 렌더레이어를 대상으로 Layout 설정
이때 좌표는 보통 부모를 기준으로 설정됩니다. Global Layout은 브라우저 사이즈가 증가하거나 폰트 사이즈가 커지면 변경된다.

4. 렌더레이어를 대상으로 칠하기
픽셀마다 점을 찍듯 칠합니다. 이를 레스터화라고도 합니다.

5. 레이어 합치기 및 표기
각각의 레이어로부터 비트맵이 생성되고 GPU에 텍스처로 업로드됩니다.
그 다음 텍스처들은 서로 합쳐져 하나의 이미지로 렌더링되며 화면으로 출력됩니다.


Q. 렌더객체와 렌더레이어는 1:1 대응일까요?
A. No
display:none으로 사라지는 노드들이 있을 수 있기 때문
하지만 DOM트리와 렌더트리는 1:1 대응
이렇게 렌더트리가 생성된 후 렌더레이어에 올려진다.
렌더레이어가 완성될 때 GPU에서 처리되는 부분이 있으면 이 요소들은 각각 강제적으로 그래픽 레이어로 분리

DOM --(1:1)o--> 렌더트리 --(1:1)x--> 렌더레이어
